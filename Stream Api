Weâ€™ll cover:

Stream Creation

Intermediate Operations

Terminal Operations

Collectors

Parallel Streams

Internal Working & Best Practices

ğŸ”¹ 1ï¸âƒ£ Stream Creation Methods
From Collection
List<String> list = Arrays.asList("A", "B", "C");
Stream<String> stream = list.stream();

From Array
int[] arr = {1,2,3};
IntStream stream = Arrays.stream(arr);

Using Stream.of()
Stream<String> stream = Stream.of("A", "B", "C");

Using Stream.generate()

Infinite stream

Stream.generate(() -> "Hello").limit(3).forEach(System.out::println);

Using Stream.iterate()
Stream.iterate(1, n -> n + 1)
      .limit(5)
      .forEach(System.out::println);

ğŸ”¹ 2ï¸âƒ£ Intermediate Operations (Lazy)

These return another stream.

âœ… filter()

Filters elements based on condition.

list.stream()
    .filter(s -> s.startsWith("A"))
    .forEach(System.out::println);


Used for: conditional selection

âœ… map()

Transforms data.

list.stream()
    .map(String::toLowerCase)
    .forEach(System.out::println);


Used for: data transformation

âœ… flatMap()

Flattens nested structures.

List<List<String>> nested = Arrays.asList(
    Arrays.asList("A","B"),
    Arrays.asList("C","D")
);

nested.stream()
      .flatMap(Collection::stream)
      .forEach(System.out::println);


Used for: List<List<T>> â†’ List<T>

âœ… distinct()

Removes duplicates.

Stream.of(1,2,2,3)
      .distinct()
      .forEach(System.out::println);

âœ… sorted()

Natural sorting:

list.stream().sorted().forEach(System.out::println);


Custom sorting:

list.stream()
    .sorted((a,b) -> b.compareTo(a))
    .forEach(System.out::println);

âœ… peek()

Debugging purpose.

list.stream()
    .peek(System.out::println)
    .map(String::toLowerCase)
    .collect(Collectors.toList());


âš  Don't use for logic.

âœ… limit()
Stream.iterate(1, n -> n+1)
      .limit(5)
      .forEach(System.out::println);

âœ… skip()
Stream.of(1,2,3,4)
      .skip(2)
      .forEach(System.out::println);

ğŸ”¹ 3ï¸âƒ£ Terminal Operations

These trigger execution.

âœ… forEach()
list.stream().forEach(System.out::println);

âœ… collect()

Most important method.

List<String> result =
    list.stream().collect(Collectors.toList());

âœ… reduce()

Used for aggregation.

int sum = Stream.of(1,2,3,4)
                .reduce(0, Integer::sum);

âœ… count()
long count = list.stream().count();

âœ… anyMatch()
boolean exists = list.stream()
                     .anyMatch(s -> s.equals("A"));

âœ… allMatch()
boolean all = list.stream()
                  .allMatch(s -> s.length() > 0);

âœ… noneMatch()
boolean none = list.stream()
                   .noneMatch(s -> s.equals("Z"));

âœ… findFirst()
Optional<String> first =
    list.stream().findFirst();

âœ… findAny()

Used mostly in parallel streams.

Optional<String> any =
    list.stream().findAny();

ğŸ”¹ 4ï¸âƒ£ Collectors (Very Important for Interviews)
toList()
.collect(Collectors.toList());

toSet()
.collect(Collectors.toSet());

joining()
String result = list.stream()
                    .collect(Collectors.joining(","));

groupingBy()
Map<Integer, List<String>> grouped =
    list.stream()
        .collect(Collectors.groupingBy(String::length));

partitioningBy()

Splits into true/false.

Map<Boolean, List<String>> partition =
    list.stream()
        .collect(Collectors.partitioningBy(s -> s.length() > 3));

counting()
long count =
    list.stream()
        .collect(Collectors.counting());

mapping()
list.stream()
    .collect(Collectors.mapping(String::toUpperCase,
             Collectors.toList()));

ğŸ”¹ 5ï¸âƒ£ Primitive Streams

Better performance.

IntStream

LongStream

DoubleStream

Example:

IntStream.range(1, 5)
         .sum();

ğŸ”¹ 6ï¸âƒ£ Parallel Streams
list.parallelStream()
    .forEach(System.out::println);


âš  Use carefully:

Avoid shared mutable state

Good for CPU-heavy operations

Not always faster

ğŸ”¹ 7ï¸âƒ£ Internal Working (Interview Gold â­)

Stream pipeline works in 3 steps:

Source

Intermediate operations (lazy)

Terminal operation (triggers execution)

Key concept: Lazy Evaluation

filter/map not executed until terminal method runs.




Parallel streams look simpleâ€¦ but they can either boost performance ğŸš€ or silently ruin your application ğŸ’€ if used wrongly.

Letâ€™s go deep.

ğŸ”¥ What is Parallel Stream?

A parallel stream divides data into multiple chunks and processes them concurrently using multiple threads.

Instead of:

list.stream()


You use:

list.parallelStream()


OR

list.stream().parallel()


Both are same.

ğŸ§  How It Works Internally

Parallel stream uses:

ForkJoinPool.commonPool()

Spliterator

Divide & Conquer algorithm

Steps internally:

Data source splits into chunks (using Spliterator)

Each chunk runs in separate thread

Results are merged (combiner function)

Think of it like:

ğŸ‘‰ Break list into parts
ğŸ‘‰ Process parts in parallel
ğŸ‘‰ Combine results

ğŸ”¹ Example 1 â€“ Basic
List<Integer> list = List.of(1,2,3,4,5,6,7,8);

list.parallelStream()
    .forEach(System.out::println);


âš  Order is NOT guaranteed.

ğŸ”¹ Ordered Output
list.parallelStream()
    .forEachOrdered(System.out::println);


âœ” Maintains order
âŒ Slightly slower

ğŸ”¹ Real Performance Example
long start = System.currentTimeMillis();

IntStream.range(1, 1_000_000)
         .parallel()
         .sum();

long end = System.currentTimeMillis();

System.out.println(end - start);


Good for:

CPU intensive tasks

Large datasets

Bad for:

Small collections

I/O operations

Database calls

ğŸš¨ VERY IMPORTANT â€“ Thread Safety Problem

âŒ Dangerous example:

List<Integer> list = new ArrayList<>();

IntStream.range(1, 1000)
         .parallel()
         .forEach(list::add);


This causes:

Race condition

Data corruption

Because ArrayList is NOT thread safe.

âœ… Safe Way

Use:

List<Integer> list =
    IntStream.range(1,1000)
             .parallel()
             .boxed()
             .collect(Collectors.toList());


Collectors handle thread safety internally.

ğŸ”¥ Reduce in Parallel (Important Interview Question)

Wrong way:

stream.parallel().reduce(0, (a,b) -> a-b);


Subtraction is NOT associative.

Parallel reduce requires:

âœ” Associative
âœ” Stateless
âœ” Non-interfering

Correct example:

stream.parallel().reduce(0, Integer::sum);

ğŸ§© When Parallel Stream Improves Performance

âœ” Large data (10k+ elements)
âœ” CPU-heavy computations
âœ” No shared mutable state
âœ” Independent operations

âŒ When It Makes Things Worse

âŒ Small collections
âŒ Blocking I/O
âŒ Database queries
âŒ Synchronized blocks
âŒ Complex stateful logic

ğŸ— ForkJoinPool Details

Parallel stream uses:

ForkJoinPool.commonPool()


Default thread count:

ğŸ‘‰ number of CPU cores - 1

You can override using:

System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "4");


But generally NOT recommended in production.

ğŸ§  Spliterator (Advanced Concept)

Spliterator:

Splits data efficiently

Supports parallel execution

Has characteristics:

ORDERED

DISTINCT

SORTED

SIZED

ArrayList splits efficiently
LinkedList splits poorly

Interview gold point â­

ğŸ”¬ Performance Reality Check

Parallel stream has overhead:

Thread management

Task splitting

Result combining

If dataset small â†’ overhead > benefit

ğŸ§ª Difference: stream() vs parallelStream()
Feature	stream()	parallelStream()
Thread	Single	Multiple
Order	Maintained	Not guaranteed
Speed	Stable	Depends
Safety	Safe	Risky if mutable
âš  Common Mistakes

Modifying shared variable

Using non-thread-safe collection

Assuming order

Using non-associative reduce

Using parallel for database calls

ğŸ’¡ Best Practice Rule

Use parallel stream only if:

âœ” Pure function
âœ” Large dataset
âœ” CPU-heavy
âœ” No shared state

Otherwise â†’ use normal stream.

ğŸš€ Interview Question: Why parallel stream is not always faster?

Answer:

Because of:

Thread creation overhead

Context switching

Splitting cost

Merge cost

Memory contention